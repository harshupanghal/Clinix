// File: Entities/Enums/AppointmentStatus.cs
namespace Clinix.Appointments.Domain.Entities.Enums
{
    public enum AppointmentStatus
    {
        Pending,
        Approved,
        Rejected,
        Cancelled,
        Completed,
        Rescheduled
    }
}

// File: Entities/ValueObjects/TimeRange.cs
using System;

namespace Clinix.Appointments.Domain.Entities.ValueObjects
{
    /// <summary>
    /// Represents a contiguous time range (inclusive start, exclusive end).
    /// </summary>
    public sealed record TimeRange(DateTimeOffset Start, DateTimeOffset End)
    {
        public TimeSpan Duration => End - Start;

        public bool Overlaps(TimeRange other) => Start < other.End && other.Start < End;

        public void Deconstruct(out DateTimeOffset start, out DateTimeOffset end) => (start, end) = (Start, End);
    }
}

// File: Entities/DoctorWorkingHours.cs
using System;
using System.Collections.Generic;

namespace Clinix.Appointments.Domain.Entities
{
    /// <summary>
    /// Defines a doctor's weekly working hours (e.g. Mon-Fri 09:00-17:00).
    /// Stored as local time range per day-of-week.
    /// </summary>
    public sealed class DoctorWorkingHours
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        // Key: DayOfWeek (0..6), Value: list of time ranges for that day (local time)
        public Dictionary<DayOfWeek, List<(TimeSpan Start, TimeSpan End)>> WeeklyHours { get; init; } = new();

        public bool IsWorkingOn(DateTimeOffset dateTime)
        {
            var local = dateTime.ToLocalTime();
            var dow = local.DayOfWeek;
            if (!WeeklyHours.TryGetValue(dow, out var ranges)) return false;
            var t = local.TimeOfDay;
            foreach (var r in ranges)
            {
                if (t >= r.Start && t < r.End) return true;
            }
            return false;
        }
    }
}

// File: Entities/Doctor.cs
using System;

namespace Clinix.Appointments.Domain.Entities
{
    /// <summary>
    /// Lightweight doctor aggregate root. Keep minimal here; richer profile is managed elsewhere.
    /// </summary>
    public sealed class Doctor
    {
        public Guid Id { get; init; }
        public string FullName { get; init; } = string.Empty;
        public string Specialty { get; init; } = string.Empty;
        public DoctorWorkingHours? WorkingHours { get; init; }

        // Concurrency token for optimistic concurrency (DB layer to manage).
        public byte[]? RowVersion { get; set; }
    }
}

// File: Entities/Patient.cs
using System;

namespace Clinix.Appointments.Domain.Entities
{
    public sealed class Patient
    {
        public Guid Id { get; init; }
        public string FullName { get; init; } = string.Empty;
        public string Phone { get; init; } = string.Empty;
        public string Email { get; init; } = string.Empty;
    }
}

// File: Entities/SymptomMapping.cs
using System;
using System.Collections.Generic;

namespace Clinix.Appointments.Domain.Entities
{
    /// <summary>
    /// Admin-controlled mapping from symptom keywords to specialties or doctor suggestions.
    /// Kept intentionally simple and extensible.
    /// </summary>
    public sealed class SymptomMapping
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public string Keyword { get; init; } = string.Empty; // normalized keyword
        public string SuggestedSpecialty { get; init; } = string.Empty;
        public List<Guid> SuggestedDoctorIds { get; init; } = new();

        // Optional confidence weight (admin tunable)
        public int Weight { get; init; } = 50;
    }
}

// File: Entities/Appointment.cs
using System;
using Clinix.Appointments.Domain.Entities.Enums;
using Clinix.Appointments.Domain.Entities.ValueObjects;
using System.Collections.Generic;

namespace Clinix.Appointments.Domain.Entities
{
    /// <summary>
    /// Aggregate root for appointments. Contains domain logic for simple validations.
    /// Heavy business operations (cascading delays) will be implemented in application/services layer.
    /// </summary>
    public sealed class Appointment
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public Guid DoctorId { get; init; }
        public Guid PatientId { get; init; }
        public DateTimeOffset StartAt { get; private set; }
        public DateTimeOffset EndAt { get; private set; }
        public AppointmentStatus Status { get; private set; } = AppointmentStatus.Pending;
        public string? Reason { get; private set; }
        public string? Notes { get; private set; }
        public DateTimeOffset CreatedAt { get; init; } = DateTimeOffset.UtcNow;
        public DateTimeOffset? UpdatedAt { get; private set; }

        // concurrency token
        public byte[]? RowVersion { get; set; }

        // Audit trail
        public List<(DateTimeOffset When, string By, string Action, string? Meta)> Audit { get; } = new();

        public Appointment(Guid doctorId, Guid patientId, DateTimeOffset startAt, DateTimeOffset endAt, string? reason = null)
        {
            if (endAt <= startAt) throw new ArgumentException("End must be after Start");
            DoctorId = doctorId;
            PatientId = patientId;
            StartAt = startAt;
            EndAt = endAt;
            Reason = reason;
            Audit.Add((DateTimeOffset.UtcNow, "system", "created", $"{StartAt:o} -> {EndAt:o}"));
        }

        public void Approve(string actor)
        {
            Status = AppointmentStatus.Approved;
            UpdatedAt = DateTimeOffset.UtcNow;
            Audit.Add((UpdatedAt.Value, actor, "approved", null));
        }

        public void Reject(string actor, string? reason = null)
        {
            Status = AppointmentStatus.Rejected;
            UpdatedAt = DateTimeOffset.UtcNow;
            Audit.Add((UpdatedAt.Value, actor, "rejected", reason));
        }

        public void Cancel(string actor, string? reason = null)
        {
            Status = AppointmentStatus.Cancelled;
            UpdatedAt = DateTimeOffset.UtcNow;
            Audit.Add((UpdatedAt.Value, actor, "cancelled", reason));
        }

        public void Reschedule(DateTimeOffset newStart, DateTimeOffset newEnd, string actor, string? note = null)
        {
            if (newEnd <= newStart) throw new ArgumentException("End must be after Start");
            var old = ($"{StartAt:o}", $"{EndAt:o}");
            StartAt = newStart;
            EndAt = newEnd;
            Status = AppointmentStatus.Rescheduled;
            UpdatedAt = DateTimeOffset.UtcNow;
            Audit.Add((UpdatedAt.Value, actor, "rescheduled", $"{old} -> {StartAt:o}:{EndAt:o}; note={note}"));
        }

        public TimeRange Range() => new(StartAt, EndAt);
    }
}

// File: Repositories/IAppointmentRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Clinix.Appointments.Domain.Entities;

namespace Clinix.Appointments.Domain.Repositories
{
    public interface IAppointmentRepository
    {
        Task<Appointment?> GetByIdAsync(Guid id);
        Task<List<Appointment>> GetAppointmentsForDoctorInRangeAsync(Guid doctorId, DateTimeOffset rangeStart, DateTimeOffset rangeEnd);
        Task<List<Appointment>> GetUpcomingAppointmentsForDoctorAsync(Guid doctorId, DateTimeOffset from);
        Task AddAsync(Appointment appointment);
        Task UpdateAsync(Appointment appointment);
        Task DeleteAsync(Guid id);
    }
}

// File: Repositories/IDoctorScheduleRepository.cs
using System;
using System.Threading.Tasks;
using Clinix.Appointments.Domain.Entities;

namespace Clinix.Appointments.Domain.Repositories
{
    public interface IDoctorScheduleRepository
    {
        Task<Doctor?> GetDoctorAsync(Guid doctorId);
        Task<DoctorWorkingHours?> GetDoctorWorkingHoursAsync(Guid doctorId);

        /// <summary>
        /// Acquire an application-level lock / concurrency token for schedule operations.
        /// Implementation detail: for SQL this may map to a RowVersion or explicit DB lock.
        /// </summary>
        Task<bool> TryAcquireScheduleLockAsync(Guid doctorId, TimeSpan lockTimeout);
        Task ReleaseScheduleLockAsync(Guid doctorId);
    }
}

// File: Repositories/ISymptomMappingRepository.cs
using System.Collections.Generic;
using System.Threading.Tasks;
using Clinix.Appointments.Domain.Entities;

namespace Clinix.Appointments.Domain.Repositories
{
    public interface ISymptomMappingRepository
    {
        Task<List<SymptomMapping>> SearchByKeywordsAsync(IEnumerable<string> keywords);
        Task AddOrUpdateAsync(SymptomMapping mapping);
        Task DeleteAsync(Guid id);
    }
}

// File: Services/INotificationService.cs
using System;
using System.Threading.Tasks;

namespace Clinix.Appointments.Domain.Services
{
    public interface INotificationService
    {
        Task NotifyPatientAsync(Guid patientId, string subject, string message);
        Task NotifyDoctorAsync(Guid doctorId, string subject, string message);
        Task NotifyAdminAsync(string subject, string message);
    }
}

// File: Exceptions/SchedulingException.cs
using System;

namespace Clinix.Appointments.Domain.Exceptions
{
    public class SchedulingException : Exception
    {
        public SchedulingException(string message) : base(message) { }
    }
}

// File: README.md
/*
 Domain layer created for the Appointments feature. It contains:
 - Entities: Appointment, Doctor, Patient, SymptomMapping, DoctorWorkingHours
 - ValueObjects: TimeRange
 - Enums: AppointmentStatus
 - Repositories interfaces: IAppointmentRepository, IDoctorScheduleRepository, ISymptomMappingRepository
 - Application services contract: INotificationService
 - Domain-level exception SchedulingException

 Next step (on your confirmation): implement the Infrastructure layer (repositories using SQL), then Application layer (use-cases: BookAppointment, Approve/Reject, DelayCascade), then Web/UI layer (Blazor components + pages + APIs).
*/

// =====================
// Application Layer
// =====================

// File: Application/DTOs/AppointmentDto.cs
using System;
using Clinix.Appointments.Domain.Entities.Enums;

namespace Clinix.Appointments.Application.DTOs
{
    public sealed record AppointmentDto(Guid Id, Guid DoctorId, Guid PatientId, DateTimeOffset StartAt, DateTimeOffset EndAt, AppointmentStatus Status, string? Reason, string? Notes);
}

// File: Application/DTOs/CreateAppointmentRequest.cs
using System;

namespace Clinix.Appointments.Application.DTOs
{
    public sealed record CreateAppointmentRequest(Guid DoctorId, Guid PatientId, DateTimeOffset StartAt, DateTimeOffset EndAt, string? Reason);
}

// File: Application/DTOs/DelayAppointmentRequest.cs
using System;

namespace Clinix.Appointments.Application.DTOs
{
    public sealed record DelayAppointmentRequest(Guid DoctorId, Guid AppointmentId, TimeSpan DelayBy, Guid RequestedBy);
}

// File: Application/Mappers/AppointmentMapper.cs
using Clinix.Appointments.Application.DTOs;
using Clinix.Appointments.Domain.Entities;

namespace Clinix.Appointments.Application.Mappers
{
    public static class AppointmentMapper
    {
        public static AppointmentDto ToDto(Appointment a) => new AppointmentDto(a.Id, a.DoctorId, a.PatientId, a.StartAt, a.EndAt, a.Status, a.Reason, a.Notes);
    }
}

// File: Application/Validators/CreateAppointmentRequestValidator.cs
using FluentValidation;
using Clinix.Appointments.Application.DTOs;

namespace Clinix.Appointments.Application.Validators
{
    public class CreateAppointmentRequestValidator : AbstractValidator<CreateAppointmentRequest>
    {
        public CreateAppointmentRequestValidator()
        {
            RuleFor(x => x.DoctorId).NotEmpty();
            RuleFor(x => x.PatientId).NotEmpty();
            RuleFor(x => x.StartAt).LessThan(x => x.EndAt).WithMessage("Start must be before End");
            RuleFor(x => x.EndAt).GreaterThan(x => x.StartAt);
            RuleFor(x => x.StartAt).GreaterThan(DateTimeOffset.UtcNow.AddMinutes(-5)).WithMessage("Start time must be in the future");
        }
    }
}

// File: Application/Interfaces/IUnitOfWork.cs
using System.Threading.Tasks;

namespace Clinix.Appointments.Application.Interfaces
{
    public interface IUnitOfWork
    {
        Task BeginAsync();
        Task CommitAsync();
        Task RollbackAsync();
    }
}

// File: Application/UseCases/BookAppointmentUseCase.cs
using System;
using System.Linq;
using System.Threading.Tasks;
using Clinix.Appointments.Application.DTOs;
using Clinix.Appointments.Application.Interfaces;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Repositories;
using Clinix.Appointments.Domain.Services;
using Clinix.Appointments.Domain.Exceptions;
using FluentValidation;

namespace Clinix.Appointments.Application.UseCases
{
    public class BookAppointmentUseCase
    {
        private readonly IAppointmentRepository _appointments;
        private readonly IDoctorScheduleRepository _schedules;
        private readonly INotificationService _notifications;
        private readonly IUnitOfWork _uow;
        private readonly IValidator<CreateAppointmentRequest> _validator;

        public BookAppointmentUseCase(IAppointmentRepository appointments, IDoctorScheduleRepository schedules, INotificationService notifications, IUnitOfWork uow, IValidator<CreateAppointmentRequest> validator)
        {
            _appointments = appointments;
            _schedules = schedules;
            _notifications = notifications;
            _uow = uow;
            _validator = validator;
        }

        public async Task<Appointment> ExecuteAsync(CreateAppointmentRequest req, string requestedBy)
        {
            var validation = await _validator.ValidateAsync(req);
            if (!validation.IsValid) throw new ValidationException(validation.Errors);

            // Basic business checks
            var doctor = await _schedules.GetDoctorAsync(req.DoctorId) ?? throw new SchedulingException("Doctor not found");
            var workHours = await _schedules.GetDoctorWorkingHoursAsync(req.DoctorId) ?? throw new SchedulingException("Doctor working hours not configured");

            if (!workHours.IsWorkingOn(req.StartAt)) throw new SchedulingException("Doctor is not working at requested start time");
            if (!workHours.IsWorkingOn(req.EndAt)) throw new SchedulingException("Doctor is not working at requested end time");

            var overlap = (await _appointments.GetAppointmentsForDoctorInRangeAsync(req.DoctorId, req.StartAt, req.EndAt)).Any();
            if (overlap) throw new SchedulingException("Requested slot is not available");

            var appointment = new Appointment(req.DoctorId, req.PatientId, req.StartAt, req.EndAt, req.Reason);

            await _uow.BeginAsync();
            try
            {
                await _appointments.AddAsync(appointment);
                await _uow.CommitAsync();

                await _notifications.NotifyDoctorAsync(req.DoctorId, "New appointment requested", $"Appointment {appointment.Id} at {appointment.StartAt:o}");
                await _notifications.NotifyPatientAsync(req.PatientId, "Appointment requested", $"Your appointment request {appointment.Id} is pending approval by the doctor.");

                return appointment;
            }
            catch
            {
                await _uow.RollbackAsync();
                throw;
            }
        }
    }
}

// File: Application/UseCases/ApproveRejectAppointmentUseCase.cs
using System.Threading.Tasks;
using Clinix.Appointments.Domain.Repositories;
using Clinix.Appointments.Domain.Services;
using Clinix.Appointments.Domain.Exceptions;

namespace Clinix.Appointments.Application.UseCases
{
    public class ApproveRejectAppointmentUseCase
    {
        private readonly IAppointmentRepository _appointments;
        private readonly INotificationService _notifications;

        public ApproveRejectAppointmentUseCase(IAppointmentRepository appointments, INotificationService notifications)
        {
            _appointments = appointments;
            _notifications = notifications;
        }

        public async Task ApproveAsync(System.Guid appointmentId, string actor)
        {
            var appt = await _appointments.GetByIdAsync(appointmentId) ?? throw new SchedulingException("Appointment not found");
            appt.Approve(actor);
            await _appointments.UpdateAsync(appt);
            await _notifications.NotifyPatientAsync(appt.PatientId, "Appointment approved", $"Your appointment {appt.Id} has been approved by the doctor.");
        }

        public async Task RejectAsync(System.Guid appointmentId, string actor, string? reason = null)
        {
            var appt = await _appointments.GetByIdAsync(appointmentId) ?? throw new SchedulingException("Appointment not found");
            appt.Reject(actor, reason);
            await _appointments.UpdateAsync(appt);
            await _notifications.NotifyPatientAsync(appt.PatientId, "Appointment rejected", $"Your appointment {appt.Id} was rejected. Reason: {reason}");
        }
    }
}

// File: Application/UseCases/DelayCascadeUseCase.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Clinix.Appointments.Application.DTOs;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Repositories;
using Clinix.Appointments.Domain.Services;
using Clinix.Appointments.Domain.Exceptions;

namespace Clinix.Appointments.Application.UseCases
{
    /// <summary>
    /// Performs a cascading delay across a doctor's upcoming appointments starting from a specific appointment.
    /// Algorithm (simplified):
    /// 1. Acquire schedule lock for doctor.
    /// 2. Fetch all upcoming appointments for doctor from the appointment's start time.
    /// 3. For each appointment in order, add the delay and ensure it's within working hours; if exceeds end-of-day, push to next working day at same start time shift preserved.
    /// 4. Persist updates in a single transaction.
    /// 5. Release lock and notify affected parties.
    /// </summary>
    public class DelayCascadeUseCase
    {
        private readonly IAppointmentRepository _appointments;
        private readonly IDoctorScheduleRepository _schedules;
        private readonly INotificationService _notifications;
        private readonly Application.Interfaces.IUnitOfWork _uow;

        public DelayCascadeUseCase(IAppointmentRepository appointments, IDoctorScheduleRepository schedules, INotificationService notifications, Application.Interfaces.IUnitOfWork uow)
        {
            _appointments = appointments;
            _schedules = schedules;
            _notifications = notifications;
            _uow = uow;
        }

        public async Task<IEnumerable<Appointment>> DelayCascadeAsync(DelayAppointmentRequest req)
        {
            if (req.DelayBy <= TimeSpan.Zero) throw new ArgumentException("Delay must be positive");

            // Acquire lock
            var locked = await _schedules.TryAcquireScheduleLockAsync(req.DoctorId, TimeSpan.FromSeconds(10));
            if (!locked) throw new SchedulingException("Could not acquire schedule lock; try again later");

            await _uow.BeginAsync();
            try
            {
                var baseAppt = await _appointments.GetByIdAsync(req.AppointmentId) ?? throw new SchedulingException("Appointment not found");
                var upcoming = (await _appointments.GetUpcomingAppointmentsForDoctorAsync(req.DoctorId, baseAppt.StartAt)).OrderBy(a => a.StartAt).ToList();

                var workingHours = await _schedules.GetDoctorWorkingHoursAsync(req.DoctorId) ?? throw new SchedulingException("Doctor working hours not configured");

                var modified = new List<Appointment>();

                // We'll shift each appointment by req.DelayBy, cascading
                foreach (var appt in upcoming)
                {
                    var newStart = appt.StartAt + req.DelayBy;
                    var newEnd = appt.EndAt + req.DelayBy;

                    // If newEnd is outside working hours of that day, roll to next working day preserving duration and relative order
                    if (!workingHours.IsWorkingOn(newStart) || !workingHours.IsWorkingOn(newEnd))
                    {
                        // Simple roll-forward: find next day where working hours accommodate the slot
                        var duration = appt.EndAt - appt.StartAt;
                        DateTimeOffset candidate = newStart;
                        bool placed = false;
                        for (int addDays = 0; addDays < 30; addDays++)
                        {
                            candidate = new DateTimeOffset(newStart.Date.AddDays(addDays + 1), newStart.Offset).Add(new TimeSpan(9,0,0)); // naive: start at 9am next day
                            var candidateEnd = candidate + duration;
                            if (workingHours.IsWorkingOn(candidate) && workingHours.IsWorkingOn(candidateEnd))
                            {
                                newStart = candidate;
                                newEnd = candidateEnd;
                                placed = true;
                                break;
                            }
                        }
                        if (!placed) throw new SchedulingException("Unable to place appointment after cascading delay within 30 days");
                    }

                    appt.Reschedule(newStart, newEnd, req.RequestedBy.ToString(), $"Cascade delay {req.DelayBy}");
                    modified.Add(appt);
                    await _appointments.UpdateAsync(appt);
                }

                await _uow.CommitAsync();

                // Notifications (fire-and-forget)
                foreach (var m in modified)
                {
                    await _notifications.NotifyPatientAsync(m.PatientId, "Appointment rescheduled", $"Your appointment {m.Id} has been moved to {m.StartAt:o}");
                }

                return modified;
            }
            catch
            {
                await _uow.RollbackAsync();
                throw;
            }
            finally
            {
                await _schedules.ReleaseScheduleLockAsync(req.DoctorId);
            }
        }
    }
}


// File: Application/README.md
/*
 Application layer implemented with:
 - DTOs: AppointmentDto, CreateAppointmentRequest, DelayAppointmentRequest
 - Mappers: AppointmentMapper
 - Validators: CreateAppointmentRequestValidator (FluentValidation)
 - Interfaces: IUnitOfWork
 - Use-cases: BookAppointmentUseCase, ApproveRejectAppointmentUseCase, DelayCascadeUseCase

 Notes / next steps:
 - Implement concrete UnitOfWork and repository implementations in the Infrastructure layer (SQL).
 - Improve DelayCascade algorithm: currently uses a naive next-day placement at 9:00 — we will improve to find the nearest available slot preserving order and respecting per-day working hour ranges when implementing infra.
 - Add more granular domain events (AppointmentRescheduled, AppointmentsDelayed) if you want to decouple notifications.
*/

// =====================
// Infrastructure Layer (EF Core)
// =====================

// File: Infrastructure/ClinixAppointmentsDbContext.cs
using System;
using Microsoft.EntityFrameworkCore;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Entities.ValueObjects;

namespace Clinix.Appointments.Infrastructure
{
    public class ClinixAppointmentsDbContext : DbContext
    {
        public ClinixAppointmentsDbContext(DbContextOptions<ClinixAppointmentsDbContext> options) : base(options) { }

        public DbSet<Appointment> Appointments { get; set; } = null!;
        public DbSet<Doctor> Doctors { get; set; } = null!;
        public DbSet<Patient> Patients { get; set; } = null!;
        public DbSet<SymptomMapping> SymptomMappings { get; set; } = null!;
        public DbSet<DoctorWorkingHours> DoctorWorkingHours { get; set; } = null!;
        public DbSet<ScheduleLock> ScheduleLocks { get; set; } = null!;

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Appointment>(b =>
            {
                b.HasKey(x => x.Id);
                b.Property(x => x.StartAt).IsRequired();
                b.Property(x => x.EndAt).IsRequired();
                b.Property(x => x.Status).HasConversion<string>().IsRequired();
                b.Property(x => x.Reason).HasMaxLength(1000);
                b.Property(x => x.Notes).HasMaxLength(2000);
                b.Property(x => x.CreatedAt).IsRequired();
                b.Property(x => x.UpdatedAt);
                b.Property(x => x.RowVersion).IsRowVersion();
            });

            modelBuilder.Entity<Doctor>(b =>
            {
                b.HasKey(x => x.Id);
                b.Property(x => x.FullName).IsRequired().HasMaxLength(200);
                b.Property(x => x.Specialty).HasMaxLength(200);
                b.Property(x => x.RowVersion).IsRowVersion();
            });

            modelBuilder.Entity<Patient>(b =>
            {
                b.HasKey(x => x.Id);
                b.Property(x => x.FullName).IsRequired().HasMaxLength(200);
                b.Property(x => x.Email).HasMaxLength(200);
                b.Property(x => x.Phone).HasMaxLength(50);
            });

            modelBuilder.Entity<SymptomMapping>(b =>
            {
                b.HasKey(x => x.Id);
                b.Property(x => x.Keyword).IsRequired().HasMaxLength(200);
                b.Property(x => x.SuggestedSpecialty).HasMaxLength(200);
                b.Property(x => x.Weight);
                b.Property(x => x.SuggestedDoctorIds).HasConversion(
                    v => string.Join(',', v),
                    v => v.Split(',', StringSplitOptions.RemoveEmptyEntries).Select(Guid.Parse).ToList()
                );
            });

            modelBuilder.Entity<DoctorWorkingHours>(b =>
            {
                b.HasKey(x => x.Id);
                // We'll store WeeklyHours as JSON
                b.Property(x => x.WeeklyHours).HasConversion(
                    v => System.Text.Json.JsonSerializer.Serialize(v, null),
                    v => System.Text.Json.JsonSerializer.Deserialize<Dictionary<DayOfWeek, List<(TimeSpan Start, TimeSpan End)>>>(v) ?? new Dictionary<DayOfWeek, List<(TimeSpan, TimeSpan)>>()
                );
            });

            modelBuilder.Entity<ScheduleLock>(b =>
            {
                b.HasKey(x => x.DoctorId);
                b.Property(x => x.LockedUntil).IsRequired(false);
            });
        }
    }
}

// File: Infrastructure/Entities/ScheduleLock.cs
using System;

namespace Clinix.Appointments.Infrastructure
{
    /// <summary>
    /// Lightweight table to implement schedule locks for doctors.
    /// Row keyed by DoctorId. We update LockedUntil to claim lock.
    /// </summary>
    public sealed class ScheduleLock
    {
        public Guid DoctorId { get; set; }
        public DateTimeOffset? LockedUntil { get; set; }
        public string? LockedBy { get; set; }
    }
}

// File: Infrastructure/Repositories/EfAppointmentRepository.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Repositories;

namespace Clinix.Appointments.Infrastructure.Repositories
{
    public class EfAppointmentRepository : IAppointmentRepository
    {
        private readonly ClinixAppointmentsDbContext _db;

        public EfAppointmentRepository(ClinixAppointmentsDbContext db) => _db = db;

        public async Task AddAsync(Appointment appointment)
        {
            _db.Appointments.Add(appointment);
            await _db.SaveChangesAsync();
        }

        public async Task DeleteAsync(Guid id)
        {
            var exist = await _db.Appointments.FindAsync(id);
            if (exist is null) return;
            _db.Appointments.Remove(exist);
            await _db.SaveChangesAsync();
        }

        public async Task<Appointment?> GetByIdAsync(Guid id) => await _db.Appointments.FindAsync(id);

        public async Task<List<Appointment>> GetAppointmentsForDoctorInRangeAsync(Guid doctorId, DateTimeOffset rangeStart, DateTimeOffset rangeEnd)
        {
            return await _db.Appointments
                .Where(a => a.DoctorId == doctorId && a.StartAt < rangeEnd && a.EndAt > rangeStart && a.Status != Domain.Entities.Enums.AppointmentStatus.Cancelled)
                .OrderBy(a => a.StartAt)
                .ToListAsync();
        }

        public async Task<List<Appointment>> GetUpcomingAppointmentsForDoctorAsync(Guid doctorId, DateTimeOffset from)
        {
            return await _db.Appointments
                .Where(a => a.DoctorId == doctorId && a.StartAt >= from && a.Status != Domain.Entities.Enums.AppointmentStatus.Cancelled)
                .OrderBy(a => a.StartAt)
                .ToListAsync();
        }

        public async Task UpdateAsync(Appointment appointment)
        {
            _db.Appointments.Update(appointment);
            await _db.SaveChangesAsync();
        }
    }
}

// File: Infrastructure/Repositories/EfDoctorScheduleRepository.cs
using System;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Repositories;

namespace Clinix.Appointments.Infrastructure.Repositories
{
    public class EfDoctorScheduleRepository : IDoctorScheduleRepository
    {
        private readonly ClinixAppointmentsDbContext _db;

        public EfDoctorScheduleRepository(ClinixAppointmentsDbContext db) => _db = db;

        public async Task<Doctor?> GetDoctorAsync(Guid doctorId) => await _db.Doctors.FindAsync(doctorId);

        public async Task<DoctorWorkingHours?> GetDoctorWorkingHoursAsync(Guid doctorId)
        {
            // Stored in DoctorWorkingHours table keyed by id == doctorId for simplicity
            return await _db.DoctorWorkingHours.FindAsync(doctorId);
        }

        public async Task<bool> TryAcquireScheduleLockAsync(Guid doctorId, TimeSpan lockTimeout)
        {
            // Implementation: Try to insert/update ScheduleLock row with LockedUntil in future using a transaction to guarantee atomicity
            var now = DateTimeOffset.UtcNow;
            var until = now.Add(lockTimeout);

            var existing = await _db.ScheduleLocks.FindAsync(doctorId);
            if (existing == null)
            {
                var sl = new ScheduleLock { DoctorId = doctorId, LockedUntil = until, LockedBy = "system" };
                _db.ScheduleLocks.Add(sl);
                try
                {
                    await _db.SaveChangesAsync();
                    return true;
                }
                catch (DbUpdateException)
                {
                    return false;
                }
            }

            if (existing.LockedUntil is null || existing.LockedUntil <= now)
            {
                existing.LockedUntil = until;
                existing.LockedBy = "system";
                _db.ScheduleLocks.Update(existing);
                await _db.SaveChangesAsync();
                return true;
            }

            return false;
        }

        public async Task ReleaseScheduleLockAsync(Guid doctorId)
        {
            var existing = await _db.ScheduleLocks.FindAsync(doctorId);
            if (existing is null) return;
            existing.LockedUntil = null;
            existing.LockedBy = null;
            _db.ScheduleLocks.Update(existing);
            await _db.SaveChangesAsync();
        }
    }
}

// File: Infrastructure/Repositories/EfSymptomMappingRepository.cs
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Repositories;

namespace Clinix.Appointments.Infrastructure.Repositories
{
    public class EfSymptomMappingRepository : ISymptomMappingRepository
    {
        private readonly ClinixAppointmentsDbContext _db;
        public EfSymptomMappingRepository(ClinixAppointmentsDbContext db) => _db = db;

        public async Task AddOrUpdateAsync(SymptomMapping mapping)
        {
            var exist = await _db.SymptomMappings.FindAsync(mapping.Id);
            if (exist == null) _db.SymptomMappings.Add(mapping);
            else _db.SymptomMappings.Update(mapping);
            await _db.SaveChangesAsync();
        }

        public async Task DeleteAsync(System.Guid id)
        {
            var e = await _db.SymptomMappings.FindAsync(id);
            if (e == null) return;
            _db.SymptomMappings.Remove(e);
            await _db.SaveChangesAsync();
        }

        public async Task<List<SymptomMapping>> SearchByKeywordsAsync(IEnumerable<string> keywords)
        {
            var k = keywords.Select(x => x.ToLowerInvariant()).ToList();
            return await _db.SymptomMappings
                .Where(m => k.Any(kw => m.Keyword.ToLower().Contains(kw)))
                .ToListAsync();
        }
    }
}

// File: Infrastructure/UnitOfWork/EfUnitOfWork.cs
using System.Threading.Tasks;
using Clinix.Appointments.Application.Interfaces;

namespace Clinix.Appointments.Infrastructure.UnitOfWork
{
    public class EfUnitOfWork : IUnitOfWork
    {
        private readonly ClinixAppointmentsDbContext _db;
        private IDbContextTransaction? _txn;

        public EfUnitOfWork(ClinixAppointmentsDbContext db) => _db = db;

        public async Task BeginAsync()
        {
            _txn = await _db.Database.BeginTransactionAsync();
        }

        public async Task CommitAsync()
        {
            if (_txn is null) return;
            await _txn.CommitAsync();
            await _txn.DisposeAsync();
            _txn = null;
        }

        public async Task RollbackAsync()
        {
            if (_txn is null) return;
            await _txn.RollbackAsync();
            await _txn.DisposeAsync();
            _txn = null;
        }
    }
}

// File: Infrastructure/Services/NotificationService.cs
using System.Threading.Tasks;
using Clinix.Appointments.Domain.Services;
using Microsoft.Extensions.Logging;

namespace Clinix.Appointments.Infrastructure.Services
{
    /// <summary>
    /// Simple notification service that logs messages. Replace with real email/SMS/provider integration.
    /// </summary>
    public class NotificationService : INotificationService
    {
        private readonly ILogger<NotificationService> _log;
        public NotificationService(ILogger<NotificationService> log) => _log = log;

        public Task NotifyAdminAsync(string subject, string message)
        {
            _log.LogInformation("[NotifyAdmin] {Subject} - {Message}", subject, message);
            return Task.CompletedTask;
        }

        public Task NotifyDoctorAsync(System.Guid doctorId, string subject, string message)
        {
            _log.LogInformation("[NotifyDoctor:{DoctorId}] {Subject} - {Message}", doctorId, subject, message);
            return Task.CompletedTask;
        }

        public Task NotifyPatientAsync(System.Guid patientId, string subject, string message)
        {
            _log.LogInformation("[NotifyPatient:{PatientId}] {Subject} - {Message}", patientId, subject, message);
            return Task.CompletedTask;
        }
    }
}

// File: Infrastructure/DI/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore;
using Clinix.Appointments.Domain.Repositories;
using Clinix.Appointments.Infrastructure.Repositories;
using Clinix.Appointments.Application.Interfaces;
using Clinix.Appointments.Infrastructure.UnitOfWork;
using Clinix.Appointments.Domain.Services;
using Clinix.Appointments.Infrastructure.Services;

namespace Clinix.Appointments.Infrastructure.DI
{
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection AddClinixAppointmentsInfrastructure(this IServiceCollection services, string connectionString)
        {
            services.AddDbContext<ClinixAppointmentsDbContext>(opt => opt.UseSqlServer(connectionString));

            services.AddScoped<IAppointmentRepository, EfAppointmentRepository>();
            services.AddScoped<IDoctorScheduleRepository, EfDoctorScheduleRepository>();
            services.AddScoped<ISymptomMappingRepository, EfSymptomMappingRepository>();
            services.AddScoped<IUnitOfWork, EfUnitOfWork>();
            services.AddScoped<INotificationService, NotificationService>();

            return services;
        }
    }
}

// File: Infrastructure/README.md
/*
 Infrastructure layer implemented for EF Core + SQL Server.
 - DbContext: ClinixAppointmentsDbContext with entities and model configuration.
 - Repositories: EfAppointmentRepository, EfDoctorScheduleRepository, EfSymptomMappingRepository.
 - Schedule lock implemented via ScheduleLock table (simple, reliable for single-instance apps; for multi-instance prefer Redis distributed lock).
 - UnitOfWork: EfUnitOfWork using DbContextTransaction.
 - NotificationService: simple logger-based implementation (replace with real provider in production).
 - DI extension method to register services.

 Next steps:
 - Create EF Migrations: `dotnet ef migrations add InitAppointments` and `dotnet ef database update`.
 - Seed initial data for doctors and working hours.
 - Implement integration tests for repository behavior and DelayCascade.
 - Then I'll implement the Web/UI layer (Blazor Server pages/components + pages for booking, doctor schedule view, admin mapping UI).
*/



// =====================
// Data Seeder
// =====================

// File: Infrastructure/Seeders/DataSeeder.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Domain.Entities.Enums;
using Microsoft.EntityFrameworkCore;

namespace Clinix.Appointments.Infrastructure.Seeders
{
    public static class DataSeeder
    {
        public static async Task SeedAsync(ClinixAppointmentsDbContext db)
        {
            if (await db.Doctors.AnyAsync()) return; // already seeded

            var doctors = new List<Doctor>
            {
                new Doctor(Guid.NewGuid(), "Dr. Alice Smith", "Cardiology"),
                new Doctor(Guid.NewGuid(), "Dr. Bob Jones", "Dermatology"),
                new Doctor(Guid.NewGuid(), "Dr. Carol Lee", "Neurology")
            };

            var patients = new List<Patient>
            {
                new Patient(Guid.NewGuid(), "John Doe", "john@example.com", "+911234567890"),
                new Patient(Guid.NewGuid(), "Jane Roe", "jane@example.com", "+919876543210")
            };

            var workingHours = new List<DoctorWorkingHours>();

            foreach (var doc in doctors)
            {
                workingHours.Add(new DoctorWorkingHours
                {
                    Id = doc.Id,
                    WeeklyHours = new Dictionary<DayOfWeek, List<(TimeSpan Start, TimeSpan End)>>
                    {
                        { DayOfWeek.Monday, new List<(TimeSpan, TimeSpan)>{ (TimeSpan.FromHours(9), TimeSpan.FromHours(17)) } },
                        { DayOfWeek.Tuesday, new List<(TimeSpan, TimeSpan)>{ (TimeSpan.FromHours(9), TimeSpan.FromHours(17)) } },
                        { DayOfWeek.Wednesday, new List<(TimeSpan, TimeSpan)>{ (TimeSpan.FromHours(9), TimeSpan.FromHours(17)) } },
                        { DayOfWeek.Thursday, new List<(TimeSpan, TimeSpan)>{ (TimeSpan.FromHours(9), TimeSpan.FromHours(17)) } },
                        { DayOfWeek.Friday, new List<(TimeSpan, TimeSpan)>{ (TimeSpan.FromHours(9), TimeSpan.FromHours(17)) } }
                    }
                });
            }

            await db.Doctors.AddRangeAsync(doctors);
            await db.Patients.AddRangeAsync(patients);
            await db.DoctorWorkingHours.AddRangeAsync(workingHours);

            await db.SaveChangesAsync();
        }
    }
}



// =====================
// UI Integration with Application Layer
// =====================

// File: Web/Pages/BookAppointment.razor (Updated for real recommendation & IDs)
@page "/book-appointment"
@inject BookAppointmentUseCase BookAppointmentUseCase
@inject ISymptomMappingRepository SymptomMappingRepository
@inject IAppointmentRepository AppointmentRepository
@inject IPatientRepository PatientRepository
@inject NavigationManager Navigation
@inject Blazored.Toast.Services.IToastService ToastService

<h3>Book Appointment</h3>
<div class="card p-4 shadow-sm">
    <div class="mb-3">
        <label>Enter your symptoms / issue</label>
        <input @bind="SearchKeyword" @oninput="SearchDoctorsAsync" class="form-control" placeholder="e.g., chest pain, rash" />
    </div>

    <div class="mb-3">
        <label>Recommended Doctors</label>
        <select @bind="SelectedDoctorId" class="form-select">
            <option value="">Select a doctor</option>
            @foreach(var d in SuggestedDoctors)
            {
                <option value="@d.Id">@d.FullName (@d.Specialty)</option>
            }
        </select>
    </div>

    <div class="mb-3">
        <label>Appointment Date & Time</label>
        <input type="datetime-local" @bind="AppointmentDateTime" class="form-control" />
    </div>

    <div class="mb-3">
        <label>Reason / Symptoms</label>
        <textarea @bind="Reason" class="form-control" rows="3"></textarea>
    </div>

    <button class="btn btn-primary" @onclick="BookAppointmentAsync">Book Appointment</button>
</div>

@code {
    private string SearchKeyword { get; set; } = string.Empty;
    private Guid SelectedDoctorId { get; set; }
    private DateTime AppointmentDateTime { get; set; } = DateTime.Now.AddHours(1);
    private string Reason { get; set; } = string.Empty;

    private List<Doctor> SuggestedDoctors { get; set; } = new();

    private async Task SearchDoctorsAsync(ChangeEventArgs e)
    {
        // Use symptom mapping to suggest doctors
        if (string.IsNullOrWhiteSpace(SearchKeyword)) { SuggestedDoctors.Clear(); return; }

        var mappings = await SymptomMappingRepository.SearchByKeywordsAsync(new[] { SearchKeyword });
        var doctorIds = mappings.SelectMany(m => m.SuggestedDoctorIds).Distinct();
        SuggestedDoctors = (await Task.WhenAll(doctorIds.Select(id => AppointmentRepository.GetDoctorByIdAsync(id)))).Where(d => d != null).ToList()!;
    }

    private async Task BookAppointmentAsync()
    {
        if (SelectedDoctorId == Guid.Empty) { ToastService.ShowWarning("Please select a doctor."); return; }

        var patientId = Guid.NewGuid(); // Replace with logged-in patient's ID
        var req = new CreateAppointmentRequest(SelectedDoctorId, patientId, AppointmentDateTime, AppointmentDateTime.AddMinutes(30), Reason);

        try
        {
            var appt = await BookAppointmentUseCase.ExecuteAsync(req, patientId.ToString());
            ToastService.ShowSuccess($"Appointment booked for {appt.StartAt:yyyy-MM-dd HH:mm}");
            Navigation.NavigateTo("/appointments");
        }
        catch(Exception ex)
        {
            ToastService.ShowError(ex.Message);
        }
    }
}


// File: Web/Pages/DoctorSchedule.razor (Updated Approve/Reject Integration)
@page "/doctor-schedule"
@inject IAppointmentRepository AppointmentRepository
@inject ApproveRejectAppointmentUseCase ApproveRejectAppointmentUseCase
@inject Blazored.Toast.Services.IToastService ToastService

<h3>Doctor Schedule</h3>
<div class="card p-4 shadow-sm">
    <table class="table table-striped">
        <thead><tr><th>Time</th><th>Patient</th><th>Status</th><th>Actions</th></tr></thead>
        <tbody>
            @foreach(var a in Appointments)
            {
                <tr>
                    <td>@a.StartAt:HH:mm - @a.EndAt:HH:mm</td>
                    <td>@a.PatientId</td>
                    <td>@a.Status</td>
                    <td>
                        @if(a.Status == Clinix.Appointments.Domain.Entities.Enums.AppointmentStatus.Pending)
                        {
                            <button class="btn btn-success btn-sm me-1" @onclick="()=>Approve(a.Id)">Approve</button>
                            <button class="btn btn-danger btn-sm" @onclick="()=>Reject(a.Id)">Reject</button>
                        }
                        else
                        {
                            <span class="text-muted">No actions</span>
                        }
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

@code {
    private List<Appointment> Appointments = new();

    protected override async Task OnInitializedAsync()
    {
        var doctorId = Guid.NewGuid(); // Replace with logged-in doctor ID
        Appointments = await AppointmentRepository.GetUpcomingAppointmentsForDoctorAsync(doctorId);
    }

    private async Task Approve(Guid id)
    {
        try
        {
            await ApproveRejectAppointmentUseCase.ApproveAsync(id, "doctor");
            ToastService.ShowSuccess("Appointment approved");
            Appointments = await AppointmentRepository.GetUpcomingAppointmentsForDoctorAsync(Guid.NewGuid());
        }
        catch(Exception ex)
        {
            ToastService.ShowError(ex.Message);
        }
    }

    private async Task Reject(Guid id)
    {
        try
        {
            await ApproveRejectAppointmentUseCase.RejectAsync(id, "doctor", "Doctor rejected");
            ToastService.ShowSuccess("Appointment rejected");
            Appointments = await AppointmentRepository.GetUpcomingAppointmentsForDoctorAsync(Guid.NewGuid());
        }
        catch(Exception ex)
        {
            ToastService.ShowError(ex.Message);
        }
    }
}


// File: Web/Pages/DoctorDelayCascade.razor (Optional for doctor cascading delays)
@page "/doctor-delay"
@inject DelayCascadeUseCase DelayCascadeUseCase
@inject IAppointmentRepository AppointmentRepository
@inject Blazored.Toast.Services.IToastService ToastService

<h3>Delay Appointments (Emergency)</h3>
<div class="card p-4 shadow-sm">
    <div class="mb-3">
        <label>Select Appointment to Delay</label>
        <select @bind="SelectedAppointmentId" class="form-select">
            <option value="">Select</option>
            @foreach(var a in UpcomingAppointments)
            {
                <option value="@a.Id">@a.StartAt:HH:mm - @a.EndAt:HH:mm (Patient: @a.PatientId)</option>
            }
        </select>
    </div>

    <div class="mb-3">
        <label>Delay Duration (minutes)</label>
        <input type="number" @bind="DelayMinutes" class="form-control" />
    </div>

    <button class="btn btn-warning" @onclick="DelayAppointmentsAsync">Apply Delay</button>
</div>

@code {
    private List<Appointment> UpcomingAppointments = new();
    private Guid SelectedAppointmentId { get; set; }
    private int DelayMinutes { get; set; } = 60;

    protected override async Task OnInitializedAsync()
    {
        var doctorId = Guid.NewGuid(); // replace with logged-in doctor ID
        UpcomingAppointments = await AppointmentRepository.GetUpcomingAppointmentsForDoctorAsync(doctorId);
    }

    private async Task DelayAppointmentsAsync()
    {
        if (SelectedAppointmentId == Guid.Empty) { ToastService.ShowWarning("Select an appointment"); return; }

        try
        {
            var req = new DelayAppointmentRequest(Guid.NewGuid(), SelectedAppointmentId, TimeSpan.FromMinutes(DelayMinutes), Guid.NewGuid());
            await DelayCascadeUseCase.DelayCascadeAsync(req);
            ToastService.ShowSuccess("Appointments delayed successfully");
            StateHasChanged();
        }
        catch(Exception ex)
        {
            ToastService.ShowError(ex.Message);
        }
    }
}


// File: Web/Pages/Admin/SymptomMapping.razor
@page "/admin/symptom-mapping"
@inject ISymptomMappingRepository SymptomMappingRepository

<h3>Admin Symptom Mapping</h3>
<div class="card p-4 shadow-sm">
    <table class="table table-bordered">
        <thead><tr><th>Keyword</th><th>Specialty</th><th>Suggested Doctors</th><th>Weight</th><th>Actions</th></tr></thead>
        <tbody>
            @foreach(var sm in Mappings)
            {
                <tr>
                    <td>@sm.Keyword</td>
                    <td>@sm.SuggestedSpecialty</td>
                    <td>@string.Join(",", sm.SuggestedDoctorIds)</td>
                    <td>@sm.Weight</td>
                    <td>
                        <button class="btn btn-danger btn-sm" @onclick="()=>Delete(sm.Id)">Delete</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

@code {
    private List<SymptomMapping> Mappings = new();

    protected override async Task OnInitializedAsync()
    {
        Mappings = await SymptomMappingRepository.SearchByKeywordsAsync(new List<string>{""});
    }

    private async Task Delete(Guid id)
    {
        await SymptomMappingRepository.DeleteAsync(id);
        Mappings.RemoveAll(m => m.Id == id);
    }
}




// =====================
// Real-Time Notifications & Updates
// =====================

// File: Infrastructure/Services/NotificationHub.cs
using Microsoft.AspNetCore.SignalR;

namespace Clinix.Appointments.Infrastructure.Services
{
    public class NotificationHub : Hub
    {
        public async Task SendNotification(string userId, string message)
        {
            await Clients.User(userId).SendAsync("ReceiveNotification", message);
        }
    }
}


// File: Application/UseCases/NotifyAppointmentChangeUseCase.cs
using Clinix.Appointments.Domain.Entities;
using Clinix.Appointments.Infrastructure.Services;
using Microsoft.AspNetCore.SignalR;
using System.Threading.Tasks;

namespace Clinix.Appointments.Application.UseCases
{
    public class NotifyAppointmentChangeUseCase
    {
        private readonly IHubContext<NotificationHub> _hubContext;

        public NotifyAppointmentChangeUseCase(IHubContext<NotificationHub> hubContext)
        {
            _hubContext = hubContext;
        }

        public async Task NotifyAsync(string userId, string message)
        {
            await _hubContext.Clients.User(userId).SendAsync("ReceiveNotification", message);
        }
    }
}


// File: Web/Shared/Notification.razor
@inject NavigationManager Navigation
@implements IAsyncDisposable
@inject IJSRuntime JS

<div class="toast-container position-fixed bottom-0 end-0 p-3">
    @foreach(var msg in Notifications)
    {
        <div class="toast show" role="alert">
            <div class="toast-body">
                @msg
            </div>
        </div>
    }
</div>

@code {
    private List<string> Notifications = new();
    private HubConnection? _hubConnection;

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/notificationhub"))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<string>("ReceiveNotification", (message) =>
        {
            Notifications.Add(message);
            StateHasChanged();
        });

        await _hubConnection.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
            await _hubConnection.DisposeAsync();
    }
}


// Program.cs (Add SignalR)
builder.Services.AddSignalR();
app.MapHub<NotificationHub>("/notificationhub");


// Usage: Call NotifyAppointmentChangeUseCase in Appointment-related actions
// e.g., after booking, approval, rejection, delay cascade:
await _notifyUseCase.NotifyAsync(patientId.ToString(), $"Your appointment with Dr. {doctor.FullName} at {appointment.StartAt:HH:mm} has been {appointment.Status}.");
await _notifyUseCase.NotifyAsync(doctorId.ToString(), $"Appointment with patient {patient.FullName} at {appointment.StartAt:HH:mm} has been {appointment.Status}.");

/*
Now:
- Patients & doctors get real-time notifications via SignalR
- Notification.razor component renders toast messages
- Works with all appointment updates: booking, approval, rejection, delay cascade
*/
